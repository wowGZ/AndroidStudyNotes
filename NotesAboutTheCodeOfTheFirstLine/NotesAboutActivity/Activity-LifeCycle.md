---
title: Activity-LifeCycle
---
## 活动的生命周期

### 返回栈

Android中的活动其实是可以层叠的。我们每启动一个活动，就会覆盖在原来的活动上面，然后点击Back键就会销毁最上层的活动，下面的活动就会重新显现出来。

其实Android是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称为返回栈。

也就是说， **当我们启动了一个新的活动的时候，这个活动就会入栈，并且位于栈顶，而当我们使用Back键或者使用finish()方法结束活动的时候，处于栈顶的当前活动就会出栈，然后前一个入栈的活动就会继续位于栈顶。**
**系统总是会显示位于栈顶的活动给用户。**

### 活动的状态

每个活动在其生命周期中最多有四个状态

#### 运行状态

当一个活动在返回栈的栈顶的时候，就是处于运行状态。 *回收处于运行状态的活动会带来非常差的用户体验*

#### 暂停状态

当一个活动不处于栈顶，但是仍然可见的时候，活动就是进入了暂停的状态。 *只有当内存极度缺少的时候，系统才会回收处于这种状态的活动*

#### 停止状态

当一个活动不处于栈顶的时候，并且完全不可见的时候，活动就进入了停止的状态。 *但是系统还是会为这种活动保存响应的状态和成员变量，这并不是一直这样的，而是如果在其他地方需要内存的时候，这里的活动就会被销毁*

#### 销毁状态

当一个活动从返回栈中移除了之后就会变成了销毁的状态。系统最倾向于回收这种活动，从而保证系统的内存充足。

### 活动的生存期

Activity类中定义了七个回调方法，覆盖了活动生命周期的每一个环节，下面就来一一介绍这七个方法：

1. onCreate():这个方法会在活动第一次被创建的时候被调用。应该 **在这个方法中进行初始化操作，比如：加载布局、绑定事件等。**
2. onStart():这个方法 **在活动从不可见变为可见的时候被调用。**
3. onResume():这个方法 **在活动准备好和用户交互的时候被调用。** 此时活动 **必须位于栈顶，而且处于运行状态。**
4. onPause():这个方法 **在系统准备去启动或者恢复另外一个活动的时候被调用** 通常在这个方法中，我们会将一些消耗CPU的资源释放掉，以及保存一些关键的数据，但是这个方法的执行速度要快，不然会影响到新的栈顶活动的使用。
5. onStop():这个方法 **在活动完全不可见的时候调用**，它和onPause()方法的区别在于，如果启动的新活动是一个对话框式的活动，那么onPause()方法会得到执行，而onStop()不会执行。
6. onDestory():这个方法 **在活动被销毁的时候被调用**，之后的活动就会变为销毁状态。
7. onRestart():这个方法 **在活动由停止状态转变为运行状态之前调用**，也就是说活动被重新启动了。

以上的七个方法除了onRestart()以外，都是两两对应的，又可以分为3种生存期。

1. 完整生存期：活动在onCreate()和onDestory()之间所经历的过程，就是完整生存期。一般一个活动会在onCreate()方法中进行初始化操作，而在onDestory()中完成释放内存的操作。
2. 可见生存期：活动在onStart()和onStop()之间所经历的过程，就是可见生存期。，在这段期间里面，活动对于用户来说总是可见的。我们可以通过这两个方法来合理的管理那些对用户可见的资源。比如：在onStart()方法中对资源进行加载，而在onStop()方法中对资源进行释放，从而保持处于停止状态的活动不会占用太多的内存。
3. 前台生存期：活动在onResume()和onPause()之间所经历的过程，就是前台生存期。在这段期间里面，活动总是处于运行状态，此时的活动是可以和用户进行交互的，平时看到和接触的最多的也是这类活动。

### 活动被回收了怎么班办

一旦活动进入了停止状态非常容易被回收。但是如果我们活动中还存在这我们所需要的数据，但是活动却被回收了怎么办？

在Activity类中还为我们提供了一个onSaveInstanceState()的回调方法，这个方法保证活动在被销毁之前一定会被调用，所以我们可以通过使用这个方法来确保我们的数据在活动被销毁之前得到保存。

onSaveInstanceState()方法中携带了一个Bundle参数，而Bundle提供了一系列的方法用于保存数据，比如可以用putString()方法来保存字符串，以此类推。每个保存方法都需要两个参数，一个是键，用于之后从Bundle中取值，另一个则是真正要保存的值。

在MainActivity中添加如下代码就可以将临时数据进行保存：

```java
@Override
protected void onSaveInstanceState(Bundle outState) {
  super.onSaveInstanceState(outState);
  String tempData = "Something you have just typed";
  outState.putString("data_key", tempData);
}
```

数据已经进行了保存，但是该如何恢复呢？仔细观察其实可以发现，在onCreate()方法中其实也有一个Bundle参数，而这个参数在一般情况下所保存的都是null，但是如果在活动销毁之前是用onSaveInstanceState()方法进行了数据的保存，那么这个参数中就会保存之前在方法中保存的临时数据，我们也就可以用过正常的方法将数据进行回调，就可以起到了数据保存的作用。
代码如下：

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  Log.d(TAG, "onCreate");
  setContentView(R.layout.activity_main);
  if (savedInstanceState != null) {
    String tempData = savedInstanceState.getString("data_key");
    Log.d(TAG, tempData);
  }
}
```
